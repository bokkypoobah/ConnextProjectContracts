import {WorkerState} from '../worker/WorkerState/WorkerState'
import {Store} from 'redux'
import * as actions from '../worker/actions'
import { Connext } from './connext-client/Connext';

export interface DeferredPopulator {
  populate (): Promise<void>
  release(): void
}

export default class ChannelPopulator {
  private connext: Connext
  private store: Store<WorkerState>
  private awaiter: Promise<void> | null

  constructor (connext: Connext, store: Store<WorkerState>) {
    this.awaiter = null
    this.connext = connext
    this.store = store
  }

  public async populateDeferred (): Promise<DeferredPopulator> {
    if (this.awaiter) {
      await this.awaiter
      return this.populateDeferred()
    }

    return new Promise<DeferredPopulator>((outerResolve) => {
      this.awaiter = new Promise((resolve, reject) => {
        const populate = () => this.doPopulate()
          .then(() => {
            resolve()
            this.awaiter = null
          })
          .catch((e) => {
            reject(e)
            this.awaiter = null
          })
        outerResolve({
          populate,
          release: () => {
            this.awaiter = null
          }
        })
      })
    })
  }

  public async populate (): Promise<void> {
    if (this.awaiter) {
      return this.awaiter
    }

    this.awaiter = new Promise((resolve, reject) => {
      this.doPopulate()
        .then(() => {
          resolve()
          this.awaiter = null
        })
        .catch((e) => {
          reject(e)
          this.awaiter = null
        })
    })

    return this.awaiter
  }

  private doPopulate = async (): Promise<void> => {
    if (this.store.getState().runtime.wallet) {
      // this can be optimized into 1 call
      const channelRow = await this.connext.getChannel()

      this.store.dispatch(actions.setChannel(
        channelRow.state
      ))

        // TODO what happened to getThreads?
      //this.store.dispatch(actions.setThreads(
        // await this.connext.getThreads()
      // ))
    }
  }
}