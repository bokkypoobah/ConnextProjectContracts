/*
import { expect } from 'chai'
import MockConnext from '../../mocks/MockConnext';
import MockStore from '../../mocks/MockStore';
import * as semaphore from 'semaphore'
import WithdrawalController, { SEMAPHORE_ERROR, INCORRECT_PENDING_AMOUNT, INCORRECT_RECIPIENT } from './WithdrawalController';
import MockLogger from '../../mocks/MockLogger';
import { Connext } from '../../lib/connext-client/Connext';
import MockWeb3 from '../../mocks/MockWeb3';
import takeSem from '../../lib/takeSem';
import { Payment, SyncResult, UnsignedChannelState } from '../../lib/connext-client/types';
import { Utils } from '../../lib/connext-client/Utils';
import { EMPTY_ROOT_HASH } from '../../lib/constants';
import * as t from '../../../../client/src/testing' // this is bad

const wei = '6969'
const token = '69'
const withdrawal = { wei, token }

const hubRequestWithdrawalResponse: UnsignedChannelState = t.getChannelState('empty', {
  txCount: [6, 3],
  pendingWithdrawalToken: ['0', token],
  pendingWithdrawalWei: ['0', wei],
  timeout: Math.floor(Date.now() / 1000),
})


describe('withdrawalController', () => {

  let wc: WithdrawalController

  let mockStore: MockStore = new MockStore()
  let store = mockStore.createStore()
  let sem = semaphore(1)
  let connext: Connext
  let address: string
  let web3: MockWeb3
  const logger = new MockLogger()
  let mockConnext: MockConnext

  beforeEach(async () => {
    mockStore = new MockStore()
    address = await mockStore.setInitialWallet()
    mockStore.setGlobalTxCount(5)

    sem = semaphore(1)

    mockStore.setSem(sem)

    store = mockStore.createStore() as any

    web3 = new MockWeb3()

    mockConnext = new MockConnext(web3)
    connext = mockConnext.getMock()

    // TODO figure out how to do this with mocked sinon correctly
    connext.sync = async () => {
      return [] as SyncResult[]
    }

    wc = new WithdrawalController(store, logger as any, connext)
  })

  it(`should pass user withdrawal into connext.requestWithdrawal along with tx count, last thread update id, and address. Should queue the 'ProposePending' update returned from the hub`, async () => {
    // TODO make this a real channel update with an exchange attatched and test it with the reducer


    ; (connext as any).requestWithdrawal = async (balances: Payment, recipient: string, _address: string): Promise<UnsignedChannelState> => {
      expect(
        balances
      ).to.deep.equal(balances)

      expect(_address).equals(address)
      return hubRequestWithdrawalResponse
    }

    await wc.requestUserWithdrawal(withdrawal, hubRequestWithdrawalResponse.recipient)

    expect(
      store.getActions()
    ).to.deep.equal([
      {
        "payload": true,
        "type": 'worker/runtime/setActiveWithdrawal', // persistent?
      },
      {
        "payload": [
          {
            "state": {
              "reason": "ProposePending",
              "state": hubRequestWithdrawalResponse
            },
            "type": "channel"
          }
        ],
        "type": "worker/persistent/enqueueSyncItem"
      }

    ])
  })

  it(`should throw if the hub returns the incorrect pending wei withdrawal amount`, async () => {
    // TODO make this a real channel update with an exchange attatched and test it with the reducer


    ; (connext as any).requestWithdrawal = async (balances: Payment, recipient: string, _address: string): Promise<UnsignedChannelState> => {
      expect(
        balances
      ).to.deep.equal(balances)

      expect(_address).equals(address)
      return hubRequestWithdrawalResponse
    }

    let errorMessage: string | null = null
    await wc.requestUserWithdrawal({ ...withdrawal, wei: '420' }, hubRequestWithdrawalResponse.recipient).catch(e => {
      errorMessage = e.message
    })

    expect(
      errorMessage
    ).equals(INCORRECT_PENDING_AMOUNT)

    expect(
      store.getActions()
    ).to.deep.equal([
      {
        payload: true,
        type: 'worker/runtime/setActiveWithdrawal',
      },
      {
        payload: false,
        type: 'worker/runtime/setActiveWithdrawal',
      }
    ])
  })

  it(`should throw if the hub returns the incorrect pending token withdrawal amount`, async () => {
    // TODO make this a real channel update with an exchange attatched and test it with the reducer


    ; (connext as any).requestWithdrawal = async (balances: Payment, recipient: string, _address: string): Promise<UnsignedChannelState> => {
      expect(
        balances
      ).to.deep.equal(balances)

      expect(_address).equals(address)
      return hubRequestWithdrawalResponse
    }

    let errorMessage: string | null = null
    await wc.requestUserWithdrawal({ ...withdrawal, token: '420' }, hubRequestWithdrawalResponse.recipient).catch(e => {
      errorMessage = e.message
    })

    expect(
      errorMessage
    ).equals(INCORRECT_PENDING_AMOUNT)

    expect(
      store.getActions()
    ).to.deep.equal([
      {
        payload: true,
        type: 'worker/runtime/setActiveWithdrawal',
      },
      {
        payload: false,
        type: 'worker/runtime/setActiveWithdrawal',
      }
    ])
  })

  it(`should throw if the recipient is incorrectly returned by the hub`, async () => {
    // TODO make this a real channel update with an exchange attatched and test it with the reducer


    ; (connext as any).requestWithdrawal = async (balances: Payment, recipient: string, _address: string): Promise<UnsignedChannelState> => {
      expect(
        balances
      ).to.deep.equal(balances)

      expect(_address).equals(address)
      return hubRequestWithdrawalResponse
    }

    let errorMessage: string | null = null
    await wc.requestUserWithdrawal(withdrawal, t.mkAddress('0x333')).catch(e => {
      errorMessage = e.message
    })

    expect(
      errorMessage
    ).equals(INCORRECT_RECIPIENT)

    expect(
      store.getActions()
    ).to.deep.equal([
      {
        payload: true,
        type: 'worker/runtime/setActiveWithdrawal',
      },
      {
        payload: false,
        type: 'worker/runtime/setActiveWithdrawal',
      }
    ])
  })

  it(`
    Should throw if another operation is in progress
  `, async () => {
      await takeSem<void>(sem, async () => {
        let err: Error | null = null

        try {
          await wc.requestUserWithdrawal(withdrawal, hubRequestWithdrawalResponse.recipient)
        } catch (e) {
          err = e
        }

        expect(() => {
          if (err) throw err
        }).to.throw(SEMAPHORE_ERROR)
      })
    })
})*/
