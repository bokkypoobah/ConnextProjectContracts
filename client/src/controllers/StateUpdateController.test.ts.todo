import { expect } from 'chai'
import * as sinon from 'sinon'
import { WorkerStore, INITIAL_STATE, ZERO_STATE } from '../WorkerState/WorkerState';
import MockLogger from '../../mocks/MockLogger';
import { Connext } from '../../lib/connext-client/Connext';
import { createConnext } from '../../lib/createConnext';
import Web3 = require('web3')
import { createStore } from 'redux';
import reducers from '../reducers';
import StateUpdateController from './StateUpdateController';
import { WalletSyncData } from '../WorkerState/WalletSyncData';
import * as actions from '../actions'
import MockStore from '../../mocks/MockStore';
import ProviderOptions from './ProviderOptions';
import clientProvider from '../../lib/web3/clientProvider';
import { getChannel } from '../../lib/getChannel';

describe('StateUpdateController', () => {
  let csuc: StateUpdateController
  let store: WorkerStore
  let connext: Connext
  const logger = new MockLogger()
  let web3: Web3
  let address: string
  let provider: any

  beforeEach(async () => {
    const mockStore = new MockStore()
    address = await mockStore.setInitialWallet()

    store = createStore(reducers, INITIAL_STATE)

    store.dispatch(
      actions.setWallet(mockStore._initialState.runtime.wallet)
    )

    const providerOpts = new ProviderOptions(store).approving() as any
    provider = clientProvider(providerOpts)
    web3 = new Web3(provider)

    connext = createConnext(web3)

    csuc = new StateUpdateController(connext, store, logger as any)
  })

  afterEach(() => provider.stop())

  it('should not dequeue any items while handleStateUpdates is running', async () => {
    const syncItems: WalletSyncData[] = [{
      update: {
        reason: 'ProposePending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: ZERO_STATE,
        current: ZERO_STATE,
      }
    }]

    let handleStateUpdates = sinon.stub()

    ;(csuc as any).handleStateUpdates = handleStateUpdates
    ;(csuc as any).isUpdating = true

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    await (csuc as any).checkQueue()

    expect(
      handleStateUpdates.callCount
    ).equals(0)
  })

  it('no updates in the syncQueue should be  a no op', async () => {
    let handleStateUpdates = sinon.stub()

    ;(csuc as any).handleStateUpdates = handleStateUpdates

    await (csuc as any).checkQueue()

    expect(
      handleStateUpdates.callCount
    ).equals(0)
  })

  it('should set accept new updates after a handleStateUpdates fails', async () => {
    let handleStateUpdates = async () => {
      throw new Error('should set isUpdating back to true after this error')
    }

    ;(csuc as any).handleStateUpdates = handleStateUpdates

    const syncItems: WalletSyncData[] = [{
      update: {
        reason: 'ProposePending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: ZERO_STATE,
        current: ZERO_STATE,
      }
    }]

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    let errorWasThrown = false

    try {
      await (csuc as any).checkQueue()

    } catch(e) {
      errorWasThrown = true

    } finally {
      expect(errorWasThrown).equals(true)
      expect((csuc as any).isUpdating).equals(false)
    }
  })

  it('should set active deposit to false after handling a confirm pending for a user deposit', async () => {
    const syncItems: WalletSyncData[] = [{
      update: {
        reason: 'ConfirmPending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 5,
          pendingDepositTokenHub: '69',
          pendingDepositWeiUser: '1000'
        },
        current: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 6,
          balanceTokenHub: '69',
          balanceWeiUser: '1000',
        },
      }
    }]

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    store.dispatch(
      actions.setHasActiveDeposit(true)
    )

    expect(store.getState().runtime.hasActiveDeposit).equals(true)

    const updateHub = sinon.stub()

    updateHub.resolves([])

    connext.updateHub = updateHub

    await (csuc as any).checkQueue()

    expect(
      store.getState().runtime.hasActiveDeposit
    ).equals(false)
  })

  it('should dequeue all items', async () => {
    const syncItems: WalletSyncData[] = [{
      update: {
        reason: 'ConfirmPending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 5,
          pendingDepositTokenHub: '69',
          pendingDepositWeiUser: '1000'
        },
        current: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 6,
          balanceTokenHub: '69',
          balanceWeiUser: '1000',
        },
      }
    }]

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    const updateHub = sinon.stub()
    updateHub.resolves([])
    connext.updateHub = updateHub

    await (csuc as any).checkQueue()

    expect(
      store.getState().runtime.syncQueue.length
    ).equals(0)
  })

  it('should no op on any updates with a txGlobalCount lower than the current store', async () => {
    const syncItems: WalletSyncData[] = [{
      update: {
        reason: 'ConfirmPending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 5,
          pendingDepositTokenHub: '69',
          pendingDepositWeiUser: '1000'
        },
        current: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 6,
          balanceTokenHub: '69',
          balanceWeiUser: '1000',
        },
      }
    }]

    store.dispatch(
      actions.setChannel({
        ...ZERO_STATE,
        txCountGlobal: 7
      })
    )

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    const updateHub = sinon.stub()
    updateHub.resolves([])
    connext.updateHub = updateHub

    const validateChannelStateUpdate = sinon.stub()
    connext.validation.validateChannelStateUpdate = validateChannelStateUpdate

    await (csuc as any).checkQueue()

    expect(
      store.getState().runtime.syncQueue.length
    ).equals(0)

    expect(
      updateHub.callCount
    ).equals(0)

    expect(
      validateChannelStateUpdate.callCount
    ).equals(0)
  })

  it('should sign and validate all the updates', async () => {
    const syncItems: WalletSyncData[] = [{
      update: {
        reason: 'ConfirmPending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 5,
          pendingDepositTokenHub: '69',
          pendingDepositWeiUser: '1000'
        },
        current: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 6,
          balanceTokenHub: '69',
          balanceWeiUser: '1000',
        },
      }
    }]

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    const updateHub = sinon.stub()
    updateHub.resolves([])
    connext.updateHub = updateHub

    const validateChannelStateUpdate = sinon.spy(connext.validation, 'validateChannelStateUpdate')

    const signChannelStateUpdate = sinon.spy(connext, 'signChannelStateUpdate')

    await (csuc as any).checkQueue()

    expect(
      store.getState().runtime.syncQueue.length
    ).equals(0)

    expect(validateChannelStateUpdate.callCount).greaterThan(0)
    expect(signChannelStateUpdate.callCount).equals(1)

    expect(
      validateChannelStateUpdate.calledWith(syncItems[0].update)
    ).equals(true)

    expect(
      signChannelStateUpdate.calledWith(syncItems[0].update)
    ).equals(true)
  })

  it('should do a userAuthorizedUpdate if the update is a propose pending for a user deposit', async () => {
    const syncItems: WalletSyncData[] = [{
      isUserDeposit: true,
      update: {
        reason: 'ProposePending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          contractAddress: process.env.CONTRACT_ADDRESS!,
          txCountGlobal: 5,
          txCountChain: 5,
          pendingDepositTokenHub: '0',
          pendingDepositWeiUser: '0'
        },
        current: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          contractAddress: process.env.CONTRACT_ADDRESS!,
          txCountGlobal: 6,
          txCountChain: 6,
          pendingDepositTokenHub: '69',
          pendingDepositWeiUser: '1000',
          timeout: 69696969,
        },
      }
    }]

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    const updateHub = sinon.stub()
    updateHub.resolves([])
    connext.updateHub = updateHub

    const userAuthorizedUpdate = sinon.stub()
    connext.userAuthorizedUpdateHandler = userAuthorizedUpdate

    await (csuc as any).checkQueue()

    expect(
      store.getState().runtime.syncQueue.length
    ).equals(0)

    expect(
      updateHub.callCount
    ).equals(1)

    expect(
      userAuthorizedUpdate.callCount
    ).equals(1)

    const [callArgs] = userAuthorizedUpdate.getCall(0).args
    expect({
      user: address,
      recipient: address,
      balanceWeiHub: '0',
      balanceWeiUser: '0',
      balanceTokenHub: '0',
      balanceTokenUser: '0',
      pendingDepositWeiHub: '0',
      pendingDepositWeiUser: '1000',
      pendingDepositTokenHub: '69',
      pendingDepositTokenUser: '0',
      pendingWithdrawalWeiHub: '0',
      pendingWithdrawalWeiUser: '0',
      pendingWithdrawalTokenHub: '0',
      pendingWithdrawalTokenUser: '0',
      txCountGlobal: 6,
      txCountChain: 6,
      contractAddress: process.env.CONTRACT_ADDRESS,
      threadRoot: '0x0000000000000000000000000000000000000000000000000000000000000000',
      threadCount: 0,
      timeout: 69696969,
      sigHub: 'not testing for this',
      sigUser: 'not testing for this',
    }).to.deep.equal({
      ...callArgs,
      sigHub: 'not testing for this',
      sigUser: 'not testing for this',
    })
  })

  it('should send all signed updates back to hub', async () => {
    const syncItems: WalletSyncData[] = [{
      update: {
        reason: 'ConfirmPending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 5,
          pendingDepositTokenHub: '69',
          pendingDepositWeiUser: '1000'
        },
        current: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 6,
          balanceTokenHub: '69',
          balanceWeiUser: '1000',
        },
      }
    }]

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    const updateHub = sinon.stub()
    updateHub.resolves([])
    connext.updateHub = updateHub

    const validateChannelStateUpdate = sinon.spy(connext.validation, 'validateChannelStateUpdate')

    const signChannelStateUpdate = sinon.spy(connext, 'signChannelStateUpdate')

    await (csuc as any).checkQueue()

    expect(
      store.getState().runtime.syncQueue.length
    ).equals(0)

    expect(validateChannelStateUpdate.callCount).greaterThan(0)
    expect(signChannelStateUpdate.callCount).equals(1)
    expect(updateHub.callCount).equals(1)

    expect(
      !!updateHub.getCall(0).args[0][0].state.sigUser
    ).equals(true)

    expect(
      validateChannelStateUpdate.calledWith(syncItems[0].update)
    ).equals(true)

    expect(
      signChannelStateUpdate.calledWith(syncItems[0].update)
    ).equals(true)
  })

  it('should set the channel to the latest double signed update', async () => {
    const syncItems: WalletSyncData[] = [{
      update: {
        reason: 'ConfirmPending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 5,
          pendingDepositTokenHub: '69',
          pendingDepositWeiUser: '1000'
        },
        current: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          sigHub: 'exists will stub out validation',
          txCountGlobal: 6,
          balanceTokenHub: '69',
          balanceWeiUser: '1000',
        },
      }
    }]

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    const updateHub = sinon.stub()
    updateHub.resolves([])
    connext.updateHub = updateHub

    const validateChannelStateUpdate = sinon.stub(connext.validation, 'validateChannelStateUpdate')
    validateChannelStateUpdate.resolves(null)

    const signChannelStateUpdate = sinon.spy(connext, 'signChannelStateUpdate')

    await (csuc as any).checkQueue()

    expect({
      ...getChannel(store),
      sigUser: 'not testing this'
    }).to.deep.equal({
      ...syncItems[0].update.current,
      sigUser: 'not testing this'
    })
  })

  it('should not update the store until after receiving a 200 from updating the hub', async () => {
    const syncItems: WalletSyncData[] = [{
      update: {
        reason: 'ConfirmPending',
        hubAddress: process.env.HUB_ADDRESS!,
        previous: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          txCountGlobal: 5,
          pendingDepositTokenHub: '69',
          pendingDepositWeiUser: '1000'
        },
        current: {
          ...ZERO_STATE,
          user: address,
          recipient: address,
          sigHub: 'exists will stub out validation',
          txCountGlobal: 6,
          balanceTokenHub: '69',
          balanceWeiUser: '1000',
        },
      }
    }]

    store.dispatch(
      actions.enqueueSyncItems(syncItems)
    )

    const updateHub = sinon.stub()
    updateHub.rejects('error')
    connext.updateHub = updateHub

    const validateChannelStateUpdate = sinon.stub(connext.validation, 'validateChannelStateUpdate')
    validateChannelStateUpdate.resolves(null)

    const signChannelStateUpdate = sinon.spy(connext, 'signChannelStateUpdate')

    let err: Error|null = null
    try {
      await (csuc as any).checkQueue()
    } catch(e) {
      err = e
    }

    expect(err).to.not.equal(null)

    expect(
      getChannel(store)
    ).to.deep.equal(ZERO_STATE)
  })

  it('should validate exchanges')

  describe('ChannelUpdate happy paths', () => {
    it('should work with a ProposePending for a user deposit')
    it('should work with a ProposePending for a hub deposit')
    it('should work for an exchange')
    it('should work for a confirm pending')
    it('should work for a tip')
    it('should work for a proposeWithrdrawal')
    it('should work for a confirmed withdrawal')
  })

  describe('StateUpdateController:ValidationErrors', () => {

  })
})

